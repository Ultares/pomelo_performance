package protocol;
import "Team.proto";
import "PlayerBasic.proto";
import "Card.proto";
import "Error.proto";
import "Strategy.proto";

// 战斗类型
enum EBattleType {
  BATTLE_TYPE_INVALID = 0;
  BATTLE_TYPE_PVE = 1;
  BATTLE_TYPE_ARENA = 2;
  BATTLE_TYPE_SNAKE = 3;
  BATTLE_TYPE_GLORY = 4;
  BATTLE_TYPE_RECRUIT = 5;
  BATTLE_TYPE_STARGAME = 6;
  BATTLE_TYPE_PVP = 7;
  BATTLE_TYPE_LEAGUE = 8;
  BATTLE_TYPE_COMPARE = 9;
  BATTLE_TYPE_ALLSTAR = 10;
}

// 回合类型
enum EBattleRoundType {
  BATTLE_ROUND_TYPE_GAME_START = 0;                 // 开始
  BATTLE_ROUND_TYPE_GANK = 1;                       // Gank
  BATTLE_ROUND_TYPE_GROUP = 2;                      // 团战
  BATTLE_ROUND_TYPE_GAME_END = 3;                   // 结束
  BATTLE_ROUND_TYPE_NONE = 4;                       // ?
  BATTLE_ROUND_TYPE_PUSH = 5;                       // Push
  BATTLE_ROUND_TYPE_AFTER_END = 6;                  // GAME_END之后的回合（剧本类型为PUSH，战斗过程按团战算）
  BATTLE_ROUND_TYPE_DRAGON = 7;                     // 打龙
  BATTLE_ROUND_TYPE_TOWER = 8;                      // 推塔
  BATTLE_ROUND_TYPE_SKIP = 9;                       // round_type是这个类型的时候只播左下角的内容，不打架，除了round_id,round_type,skip_data其他字段都没有。
}

// 各种称号
enum BattleTitleType {
  BATTLE_TITLE_TYPE_INVALID = 0;
  BATTLE_TITLE_TYPE_TANK = 1;                       // 坦克
  BATTLE_TITLE_TYPE_KILL = 2;                       // 击杀
  BATTLE_TITLE_TYPE_ATTACK = 3;                     // 高伤
  BATTLE_TITLE_TYPE_SUPPORT = 4;                    // 助攻王
  BATTLE_TITLE_TYPE_PUSH_TOWER = 5;                 // 推塔
  BATTLE_TITLE_TYPE_MVP = 6;                        // MVP
}

// 战斗状态
enum EBattleStatus {
  BATTLE_STATUS_INVALID = 0;
  BATTLE_STATUS_PREPARING = 1;
  BATTLE_STATUS_END = 2;
  BATTLE_STATUS_GANK = 3;
  BATTLE_STATUS_GROUP = 4;
  BATTLE_STATUS_IDLE = 5;
  BATTLE_STATUS_DRAGON = 6;
  BATTLE_STATUS_TOWER = 7;
}

message CastSkillData {
  optional uint32 skill_uid = 1;                    // skill_id * 100 + skill_level
  // optional uint32 color = 2;                        // 技能目标的阵营：1是蓝方；2是红方
  // optional ECardPosition position = 3;              // 技能的目标位置
  repeated uint32 target_refresh_ids = 4;           // 技能的目标位置
}

// 选手数据
message BattleCardData {
  optional ECardPosition position = 1;              // 位置
  optional uint32 hero_id = 2;                      // （回合外）使用的英雄
  optional uint32 score = 3;                        // （回合外、回合内）评分*1000
  repeated BattleTitleType titles = 4;              // （回合外）称号
  optional CardProp card_prop = 5;                  // （回合外、回合内）选手的card_id和战斗力
  // optional uint32 cast_skill = 6;                   // （回合内）是否施放技能，一个round里最多只有一个选手施放技能，0或nil表示没有施放技能
  // repeated uint32 buff_ids = 7;                     // （回合内）携带的buff
  repeated SkillData buffs = 8;                     // （回合内）受到的buff
  optional SkillData small_skills = 9;              // （回合内）释放的普通技能
  optional SkillData skill = 10;                    // （回合内）释放的大技能
  optional uint32 hero_level = 11;                  // （回合内）当前回合中这个选手的英雄的等级
  optional double attack = 12;                      // （沙盒战斗的）攻击力
  optional double hitpoint = 13;                    // （沙盒战斗的）初始血量
  optional double hurt_weight = 14;                 // （沙盒战斗的团战回合的）承受伤害的权值
  // repeated uint32 cast_skills = 15;                 // （沙盒战斗的）skill_id * 100 + skill_level：表示释放的技能
  // repeated uint32 obtained_skills = 16;             // （沙盒战斗的）skill_id * 100 + skill_level：表示受到的技能
  // repeated ECardPosition kill_positions = 17;       // （沙盒战斗的）干掉的对面选手
  repeated CastSkillData cast_skills = 18;          // 释放的技能
  optional uint32 assist_count = 19;                // （回合内）累计助攻数
  optional double initial_hitpoint = 20;            // （沙盒战斗的）总血量
  optional uint32 money = 21;                       // （回合外）结束时每个人的经济
  optional double total_hurt = 22;                  // （回合内）对敌方造成的总伤害
  optional double total_endure = 23;                // （回合内）承受的总伤害
  optional Card card = 24;                          // （回合外）只在BattleInfo.teams.cards里有这个字段
}

// 战队数据
message BattleTeam {
  optional int32 camp = 12;                         // 1是蓝方，2是红方
  optional bool is_opponent = 1;                    // 用来区分自己还是对手：false表示自己，true表示对手
  optional BasicInfo basic_info = 2;                // （回合外）俱乐部名称、IconID、等级等信息
  repeated BattleCardData cards = 3;                // （回合外、回合内）五个位置的选手数据
  optional uint32 kill_count = 4;                   // （回合内）人头数
  optional uint32 battle_force = 5;                 // （回合内）战斗力
  optional uint32 hp = 6;                           // （回合内）回合结束时的分数
  optional uint32 total_money = 7;                  // （回合内）这个回合开始前的累计经济，可以用来校准
  optional uint32 total_kill = 8;                   // （回合内）这个回合开始前的累计人头数
  optional double money_speed = 9;                  // （沙盒战斗的）金钱获取速度
  optional uint32 delta_money = 10;                 // （回合内）这个回合战斗获得的经济，不包括发育获得的
  optional uint32 delta_kill = 11;                  // （回合内）这个回合获得的人头数
}

message SkillRecord {
  optional uint32 refresh_id = 1;                   // 触发技能者
  optional uint32 skill_lookup_id = 2;              // 触发回合的技能LookUpID
  optional uint32 param_1 = 3;                      // 参数
}

message KillRecord {
  optional uint32 killer_refresh_id = 1;            // 攻击者
  optional uint32 target_refresh_id = 2;            // 被杀者
}

message SkipRoundData {
  optional uint32 camp = 1;
  optional ECardPosition card_position = 2;
}

// 战斗回合信息
message BattleRound {
  optional uint32 round_id = 1;                     // 第几个回合，从0开始编号
  optional EBattleRoundType round_type = 2;         // 回合类型
  optional bool is_win = 3;                         // true表示本回合本方胜利，false表示本回合本方失败
  repeated BattleTeam teams = 6;                    // 不包括basic_info
  optional int32 script_id = 7;                     // 剧本编号
  optional uint32 level = 8;                        // 英雄的平均等级
  repeated uint32 kill_towers = 9;                  // 灭掉的塔
  repeated uint32 valid_script_ids = 10;
  optional uint32 time = 11;                        // 距离战斗开始的时间（单位：秒）
  repeated ECardPosition blue_targets = 12;         // （沙盒战斗的GANK回合）蓝方被集火顺序
  repeated ECardPosition red_targets = 13;          // （沙盒战斗的GANK回合）红方被集火顺序
  // repeated FightRound fight_rounds = 4;             // 圆盘战斗的经过
  // repeated AttackRound skills = 14;                 // 队长技能和特性技能，按释放顺序排列
  optional uint32 camp = 15;                        // 战斗发起方：1是蓝方，2是红方，0表示没有
  // repeated CardStatus card_status = 16;             // 大回合结束是去掉了的buff
  repeated int32 related_positions = 17;            // 参加圆盘战斗的英雄的refresh_id
  optional int32 win_camp = 18;                     // 胜利方：1是蓝方，2是红方，0表示打平
  optional int32 ruler_id = 19;                     // BattleRound类型是Gank时表示GankRuler表的ID；类型是团战是表示BattleRuler表的ID
  optional SkillRecord round_trigger = 20;          // 如果有这个字段的话，这个字段表示本回合是由谁的什么技能触发的
  repeated SkillRecord skill_records = 4;           // 战斗中触发的技能
  repeated SkillRecord last_Skill_records = 5;      // 战斗结束时触发的技能
  repeated KillRecord kill_records = 21;            // 击杀信息
  optional SkipRoundData skip_data = 22;            // round_type=SKIP时这个字段才有效
}

message CardBattleForce {
  optional int32 refresh_id = 1;
  optional double battle_force = 2;
}

// 战斗大致过程
message BattleInfo {
  optional EBattleType battle_type = 1;             // 战斗类型
  optional bool is_win = 2;                         // true表示本方胜利，false表示本方失败
  // repeated uint32 condition_ids = 3;                // 根据双方的属性值算出来的、用于表现的局势ID
  repeated BattleRound rounds = 4;                  // （回合内）各个回合的信息
  repeated BattleTeam teams = 5;                    // （回合外）双方的基本信息和结算信息
  optional int32 win_camp = 6;                      // 胜利方：1是蓝方，2是红方
  optional StrategyPage blue_strategy_page = 7;
  optional StrategyPage red_strategy_page = 8;
  repeated CardBattleForce strategy_battle_forces = 9;  // round_id=0之后，round_id=1之前，上面两个字段影响之后所有人的战斗力
  optional bytes log_content = 10;
}

message BattleDetail {
}

// ===============================================================
// 通用战斗协议：
message C2S_SetBattleModeRequest {
  optional uint32 battle_mode = 1;                  // 设置战斗模式：1表示纯英雄战斗；2表示纯沙盘战斗；3表示结合
}

// 1）进入战斗的通知： 服务器将计算出的战斗结果和大致过程通知客户端。
message S2C_EnterBattle {
  optional BattleInfo battle_info = 1;
  optional uint32 battle_mode = 2;
  optional int32 camp = 3;                          // 阵营：1是蓝方，2是红方
  // optional S2C_StrategyUseResponse strategy_use_response = 4;
  optional ErrorCode error_code = 5;
}
// 2）客户端根据战斗结果和局势ID进行AI的战斗表现，结束后将AI表现得到的统计信息发给服务器，
message C2S_LeaveBattle {
  optional BattleDetail battle_detail = 1;
}

// 表示某个英雄所在区域的结构
message TacticCardArea {
  optional ECardPosition card_position = 1;
  repeated uint32 area_ids = 2;
}
// 战术的选项
message TacticOption {
  optional uint32 tactic_id = 1;
  optional uint32 reward_money = 2;                 // 成功的话能获得的金币
  optional double success_probability = 3;          // 成功的概率
}
// 通知服务器打野所在区域
message C2S_BattleTacticOptionRequest {
  repeated TacticCardArea card_areas = 1;
  optional uint32 round_id = 2;                     // 客户端在第几回合。客户端在收到S2C_BattleTacticResponse之后进入新的回合。
}
// 服务器根据打野所在区域计算出两个箭头
message S2C_BattleTacticOptionResponse {
  optional ErrorCode error_code = 1;
  repeated TacticOption tactic_options = 2;         // 2个可供选择的战术
  optional uint32 default_tactic_id = 3;            // 默认选项
  optional uint32 timeout_seconds = 4;              // 选择限制时间，单位：秒
  optional uint32 round_id = 5;                     // 第几回合
  optional EBattleRoundType round_type = 6;         // 回合类型
  optional uint32 battle_position = 7;              // 战斗发生的地点
}

// 分路的枚举
enum ETacticPath {
  TACTIC_PATH_INVALID = 0;
  TACTIC_PATH_TOP = 1;
  TACTIC_PATH_MIDDLE = 2;
  TACTIC_PATH_BOTTOM = 3;
  TACTIC_PATH_JUNGLE = 4;                           // 野区
}
// 客户端选择一个箭头
message C2S_BattleTacticRequest {
  optional uint32 tactic_id = 1;
  optional ETacticPath path = 2;                    // 团战所在战线
  optional uint32 round_id = 3;                     // 第几回合
}
// 通过选择的箭头计算出下个回合的信息（剧本等）
message S2C_BattleTacticResponse {
  optional ErrorCode error_code = 1;
  optional BattleRound new_round = 2;
  optional bool is_win = 3;
  optional bool finished = 4;
  repeated BattleTeam teams = 5;                    // finished=true时：双方的结算信息
  optional uint32 blue_tactic_id = 6;               // 蓝方选择的战术（箭头）
  optional uint32 red_tactic_id = 7;                // 红方选择的战术（箭头）
  optional bytes log_content = 8;                   // LOG
  optional int32 win_camp = 9;                      // 胜利方
  optional uint32 round_id = 10;                    // 第几回合
  // repeated uint32 push_turrets = 11;                // 推塔
  optional uint32 relive_time = 12;                 // 复活时间
  // optional uint32 win_camp_command = 13;            // 胜利方推塔指令
  optional int32 ruler_id = 14;                     // BattleRound类型是Gank时表示GankRuler表的ID；类型是团战是表示BattleRuler表的ID
}


// 跳过战斗（PVE）或投降（PVP）
message C2S_SkipBattleRequest {
}
message S2C_SkipBattleResponse {
  optional ErrorCode error_code = 1;
  optional BattleInfo battle_info = 2;              // 一个GameEnd类型的回合
  optional bytes log_content = 3;
}


// 进入战斗时加载完成后发送
message C2S_LoadBattleFinishRequest {
}
// 两边都加载完成后服务器通知两边
message S2C_LoadBattleFinishNotify {
}


// Server Message
message ServerBattleOption {
  optional int32 lineup_id = 1;
  optional int32 strategy_page_id = 2;
  optional int32 script_actor_limit = 3;            // 剧本参战人员不在数值演算人员的个数上限
  optional int32 script_audience_limit = 4;         // 数值演算人员不在剧本参战人员的个数上限
}
message ServerBattleCard {
  optional ECardPosition card_position = 1;
  optional CardProp card_prop = 2;
  repeated SkillData skills = 3;
}
message ServerBattleTeam {
  optional int32 camp = 1;
  optional uint64 player_uid = 2;
  repeated ServerBattleCard battle_cards = 3;
  optional StrategyPage strategy_page = 4;
}
message S2S_BattleRequest {
  optional uint64 battle_uid = 1;
  optional EBattleType battle_type = 2;
  optional ServerBattleOption battle_option = 3;
  repeated ServerBattleTeam battle_teams = 4;
  optional bool log_open = 5;
  optional uint32 glory_instance_id = 6;
}


// ===============================================================
// 打龙玩法
enum EDragonState {
  DRAGON_STATE_INVALID = 0;
  DRAGON_STATE_ENTER = 1;                           // 通知客户端进入打龙场景：is_big_dragon
  DRAGON_STATE_START = 2;                           // 通知客户端打龙逻辑开始：hitpoint
  DRAGON_STATE_HITPOINT = 3;                        // 通知客户端龙掉血或被击杀了: attacker_refresh_id, is_punish, hitpoint
                                                    // 或者/同时：通知客户端某个英雄被龙攻击了: refresh_id, hero_hitpoint
}
message C2S_DragonPrepareFinish {                   // 通知服务器打龙场景加载完毕
}
message C2S_DragonPunishReqeust {                   // 惩戒
}
message S2C_DragonNotify {
  optional EDragonState state = 1;                  // 打龙状态
  optional int32 attacker_refresh_id = 2;           // 攻击龙的英雄的refresh_id
  optional bool is_punish = 3;                      // 是否是惩戒
  optional double hitpoint = 4;                     // 龙的血量变成了多少
  optional int32 refresh_id = 5;                    // 被攻击者的refresh_id
  optional double hero_hitpoint = 6;                // 被攻击者的HP变成了多少
  optional bool is_big_dragon = 7;                  // true表示大龙；false表示小龙
}

// ===============================================================
// 推塔团战玩法
enum ETowerState {
  TOWER_STATE_INVALID = 0;
  TOWER_STATE_ENTER = 1;                            // 通知客户端进入推塔场景：camp
  TOWER_STATE_START = 2;                            // 通知客户端推塔逻辑开始（塔开始掉血）：tower_total_hp, tower_damage_speed
  TOWER_STATE_ROUNDS = 3;                           // 通知客户端进入开团状态：tower_hp, tower_rounds
}
message TowerRound {
  optional int32 refresh_id = 1;                    // 0表示塔
  optional int32 target_refresh_id = 2;             // 0表示塔
  optional double hitpoint = 3;                     // 0表示死了
}
message C2S_TowerPrepareFinish {                    // 通知服务器推塔场景加载完毕
}
message C2S_TowerPushRequest {                      // 请求直接开始团战
  optional ECardPosition smite_position = 1;        // 如果是防守方，可以选择先围殴进攻方的某个人，0表示失误
}
message S2C_TowerNotify {
  optional ETowerState state = 1;                   // 推塔状态
  optional int32 camp = 2;                          // 谁的塔（被推塔方的阵营）
  optional double tower_total_hp = 3;               // 塔的总血量
  optional double tower_hp = 4;                     // 塔的血量
  optional double tower_damage_speed = 5;           // 塔的掉血速度
  repeated TowerRound tower_rounds = 6;             // 开团状态的回合
}

